// +build ignore

package main

import (
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"os"
)

func main() {
	out, err := os.Create("wrapper.go")
	if err != nil {
		panic(err)
	}
	defer func() {
		err := out.Close()
		if err != nil {
			panic(err)
		}
	}()

	fset := token.NewFileSet()

	write := func(s string) {
		_, err := io.WriteString(out, s)
		if err != nil {
			panic(err)
		}
	}
	code := func(n interface{}) {
		err := printer.Fprint(out, fset, n)
		if err != nil {
			panic(err)
		}
	}

	write(`// Code generated by mkwrapper.go

package main

import . "github.com/BenLubar/bit/bitgen"
`)

	f, err := parser.ParseFile(fset, "../../bitgen/writer.go", nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	for _, d := range f.Decls {
		if f, ok := d.(*ast.FuncDecl); ok && f.Recv != nil && len(f.Recv.List) == 1 && f.Type.Results != nil && len(f.Type.Results.List) == 2 {
			if s, ok := f.Recv.List[0].Type.(*ast.StarExpr); ok {
				if i, ok := s.X.(*ast.Ident); !ok || i.Name != "Writer" {
					continue
				}
			} else {
				continue
			}

			if i, ok := f.Type.Results.List[0].Type.(*ast.Ident); !ok || i.Name != "int64" {
				continue
			}

			if i, ok := f.Type.Results.List[1].Type.(*ast.Ident); !ok || i.Name != "error" {
				continue
			}

			if f.Doc != nil {
				for _, c := range f.Doc.List {
					write("\n")
					write(c.Text)
				}
			}
			write("\nfunc (w *writer) ")
			code(f.Name)
			write("(")
			for i, p := range f.Type.Params.List {
				for j, n := range p.Names {
					if i != 0 || j != 0 {
						write(", ")
					}
					code(n)
				}
				write(" ")
				code(p.Type)
			}
			write(`) {
	if w.err != nil {
		return
	}

	var n int64
	n, w.err = w.Writer.`)
			code(f.Name)
			write("(")
			for i, p := range f.Type.Params.List {
				for j, n := range p.Names {
					if i != 0 || j != 0 {
						write(", ")
					}
					code(n)
				}
			}
			write(`)
	w.n += n
}
`)
		}
	}
}
