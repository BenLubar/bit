// a lot of the code in this file was taken from cmd/internal/objfile.

package main

import (
	"debug/elf"
	"debug/gosym"
	"debug/macho"
	"debug/pe"
	"debug/plan9obj"
	"encoding/gob"
	"flag"
	"fmt"
	"os"
	"sort"

	"github.com/BenLubar/bit/bitgen"
)

var (
	flagset = flag.NewFlagSet("bitprof", flag.ExitOnError)

	flagCompiler = flagset.String("compiler", "bit-compiler", "the path to the compiler used to make the map")
	flagMap      = flagset.String("map", "bit.map", "the path to the map generated by the compiler")
	flagTrace    = flagset.String("trace", "bit.trace", "the path to the trace generated by bit")
)

func main() {
	flagset.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		flagset.PrintDefaults()
	}

	if err := flagset.Parse(os.Args[1:]); err != nil {
		panic(err)
	}

	sym := symbolTable()
	mapping := codeMap()
	trace := loadTrace()

	hitMap := make(map[[64]uint64]uint64)
	for line, count := range trace {
		hitMap[mapping[bitgen.Line(line)]] += count
	}

	hits := make(hitSort, 0, len(mapping))
	for _, pc := range mapping {
		hits = append(hits, hit{
			pc:    pc,
			count: hitMap[pc],
		})
	}

	sort.Sort(hits)
	for _, h := range hits {
		fmt.Println(h.count, "hits:")
		for _, pc := range h.pc {
			if pc == 0 {
				break
			}
			file, line, fn := sym.PCToLine(pc)
			fmt.Printf("%s @ %s:%d\n", fn.Name, file, line)
		}
		fmt.Println()
	}
}

type hit struct {
	pc    [64]uint64
	count uint64
}

type hitSort []hit

func (s hitSort) Len() int           { return len(s) }
func (s hitSort) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
func (s hitSort) Less(i, j int) bool { return s[i].count > s[j].count }

func symbolTable() *gosym.Table {
	attempts := []func() (uint64, []byte, []byte, error){
		pclnElf,
		pclnMacho,
		pclnPE,
		pclnPlan9,
	}

	var errors []error

	for _, a := range attempts {
		textStart, symtab, pclntab, err := a()
		if err == nil {
			var table *gosym.Table
			table, err = gosym.NewTable(symtab, gosym.NewLineTable(pclntab, textStart))
			if err == nil {
				return table
			}
		}
		errors = append(errors, err)
	}

	for _, err := range errors {
		fmt.Fprintln(os.Stderr, err)
	}
	flagset.Usage()
	os.Exit(1)
	panic("unreachable")
}

func pclnElf() (textStart uint64, symtab, pclntab []byte, err error) {
	f, err := elf.Open(*flagCompiler)
	if err != nil {
		return
	}
	defer f.Close()

	if sect := f.Section(".text"); sect != nil {
		textStart = sect.Addr
	}
	if sect := f.Section(".gosymtab"); sect != nil {
		if symtab, err = sect.Data(); err != nil {
			return
		}
	}
	if sect := f.Section(".gopclntab"); sect != nil {
		if pclntab, err = sect.Data(); err != nil {
			return
		}
	}

	return
}

func pclnMacho() (textStart uint64, symtab, pclntab []byte, err error) {
	f, err := macho.Open(*flagCompiler)
	if err != nil {
		return
	}
	defer f.Close()

	if sect := f.Section("__text"); sect != nil {
		textStart = sect.Addr
	}
	if sect := f.Section("__gosymtab"); sect != nil {
		if symtab, err = sect.Data(); err != nil {
			return
		}
	}
	if sect := f.Section("__gopclntab"); sect != nil {
		if pclntab, err = sect.Data(); err != nil {
			return
		}
	}

	return
}

func pclnPE() (textStart uint64, symtab, pclntab []byte, err error) {
	f, err := pe.Open(*flagCompiler)
	if err != nil {
		return
	}
	defer f.Close()

	var imageBase uint64
	switch oh := f.OptionalHeader.(type) {
	case *pe.OptionalHeader32:
		imageBase = uint64(oh.ImageBase)
	case *pe.OptionalHeader64:
		imageBase = oh.ImageBase
	default:
		return 0, nil, nil, fmt.Errorf("pe file format not recognized")
	}
	if sect := f.Section(".text"); sect != nil {
		textStart = imageBase + uint64(sect.VirtualAddress)
	}
	if pclntab, err = loadPETable(f, "runtime.pclntab", "runtime.epclntab"); err != nil {
		return
	}
	if symtab, err = loadPETable(f, "runtime.symtab", "runtime.esymtab"); err != nil {
		return
	}

	return
}

func findPESymbol(f *pe.File, name string) (*pe.Symbol, error) {
	for _, s := range f.Symbols {
		if s.Name != name {
			continue
		}
		if s.SectionNumber <= 0 {
			return nil, fmt.Errorf("symbol %s: invalid section number %d", name, s.SectionNumber)
		}
		if len(f.Sections) < int(s.SectionNumber) {
			return nil, fmt.Errorf("symbol %s: section number %d is larger than max %d", name, s.SectionNumber, len(f.Sections))
		}
		return s, nil
	}
	return nil, fmt.Errorf("no %s symbol found", name)
}

func loadPETable(f *pe.File, sname, ename string) ([]byte, error) {
	ssym, err := findPESymbol(f, sname)
	if err != nil {
		return nil, err
	}
	esym, err := findPESymbol(f, ename)
	if err != nil {
		return nil, err
	}
	if ssym.SectionNumber != esym.SectionNumber {
		return nil, fmt.Errorf("%s and %s symbols must be in the same section", sname, ename)
	}
	sect := f.Sections[ssym.SectionNumber-1]
	data, err := sect.Data()
	if err != nil {
		return nil, err
	}
	return data[ssym.Value:esym.Value], nil
}

func pclnPlan9() (textStart uint64, symtab, pclntab []byte, err error) {
	f, err := plan9obj.Open(*flagCompiler)
	if err != nil {
		return
	}
	defer f.Close()

	textStart = f.LoadAddress + f.HdrSize
	if pclntab, err = loadPlan9Table(f, "runtime.pclntab", "runtime.epclntab"); err != nil {
		return
	}
	if symtab, err = loadPlan9Table(f, "runtime.symtab", "runtime.esymtab"); err != nil {
		return
	}
	return
}

func findPlan9Symbol(f *plan9obj.File, name string) (*plan9obj.Sym, error) {
	syms, err := f.Symbols()
	if err != nil {
		return nil, err
	}
	for _, s := range syms {
		if s.Name != name {
			continue
		}
		return &s, nil
	}
	return nil, fmt.Errorf("no %s symbol found", name)
}

func loadPlan9Table(f *plan9obj.File, sname, ename string) ([]byte, error) {
	ssym, err := findPlan9Symbol(f, sname)
	if err != nil {
		return nil, err
	}
	esym, err := findPlan9Symbol(f, ename)
	if err != nil {
		return nil, err
	}
	sect := f.Section("text")
	if sect == nil {
		return nil, err
	}
	data, err := sect.Data()
	if err != nil {
		return nil, err
	}
	textStart := f.LoadAddress + f.HdrSize
	return data[ssym.Value-textStart : esym.Value-textStart], nil
}

func codeMap() map[bitgen.Line][64]uint64 {
	var mapping map[bitgen.Line][64]uint64

	f, err := os.Open(*flagMap)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		flagset.Usage()
		os.Exit(1)
		panic("unreachable")
	}
	defer f.Close()

	err = gob.NewDecoder(f).Decode(&mapping)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		flagset.Usage()
		os.Exit(1)
		panic("unreachable")
	}

	return mapping
}

func loadTrace() map[uint64]uint64 {
	var trace map[uint64]uint64

	f, err := os.Open(*flagTrace)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		flagset.Usage()
		os.Exit(1)
		panic("unreachable")
	}
	defer f.Close()

	err = gob.NewDecoder(f).Decode(&trace)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		flagset.Usage()
		os.Exit(1)
		panic("unreachable")
	}

	return trace
}
